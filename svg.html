<html>
  <head>
    <title>SVG hack</title>
    <link rel="stylesheet" href="https://use.typekit.net/srk3hpl.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/svg.js/3.0.16/svg.min.js" integrity="sha512-p3Tp2zn+wApBreZCgRkmMwnfpN8MUPXzzOihXx7iGYXqE7t6m9drY8HeyMeeFuDWiTFKrGUrq3jpbT0vX6zY/Q==" crossorigin="anonymous"></script>
  </head>
  <body>
    <p>
    <img src="sample.png" height="320"/>
    </p>
    <script>
    SVG.extend(SVG.Box, {
      grow: function(amount) {
        this.x -= amount;
        this.y -= amount;
        this.width += amount * 2;
        this.height += amount * 2;
        return this;
      }
    });

    SVG.extend(SVG.Defs, {
      multiply: function(background) {
        const id = SVG.eid("multiply-filter")
        let f = this.element("filter").attr({"id": id, x: "0", y: "0", width: "100%", height: "100%"});
        // Seem to need to flood and can't just use in2=BackgroundImage?
        f.element('feFlood').attr({"flood-color": background});
        f.element("feBlend").attr({mode: "multiply", in: "SourceGraphic"});
        return id;
      }
    });

    SVG.extend(SVG.Svg, {
      star: function(spikes, outer, inner) {
        var points = [];
        const degrees = 360/spikes;
        for (i = 0; i < spikes; i++) {
          a = i * degrees + 90
          x = outer + inner * Math.cos(a * Math.PI / 180)
          y = outer + inner * Math.sin(a * Math.PI / 180)

          points.push([x, y])

          a += degrees / 2
          x = outer + outer * Math.cos(a * Math.PI / 180)
          y = outer + outer * Math.sin(a * Math.PI / 180)

          points.push([x, y])
        }
        return this.polyline(points);
      },

      style: function(selector, rules) {
        /* This can be removed when upgrading svgjs */
        this.put(new SVG.Style()).rule(selector, rules);
      }
    });

    SVG.extend(SVG.Element, {
      addOutline: function() {
        this.clone().addClass("outline").insertBefore(this);
      }
    });

    SVG.extend(SVG.Text, {
      wrap: function(string, maxWidth) {
        const words = string.split(/\s+/);
        var span = this.tspan('');
        let line = ''
        for(var n = 0; n < words.length; n++) {
          span.text(line + words[n] + " ");
          if (span.length() > maxWidth && n > 0) {
            span.text(line);
            span.newLine();
            span = this.tspan(words[n] + '');
            line = words[n] + " ";
          } else {
            line = span.text()
          }
        }
        span.newLine();
      }
    });

    function renderItem(item) {
      const padding = 8;

      var draw = SVG().addTo('body').size(150 * item.width, 150 * item.height);

      draw.style('.stroke', {fill: 'white', stroke: 'black', 'stroke-width': '2px' });
      draw.style('.header', {fill: 'black', font: '20px ff-brokenscript-bc-web, serif' });
      draw.style('text.damage', {fill: 'black', font: 'bold 16px interstate-condensed, sans-serif' });
      draw.style('.mechanics', {fill: 'black', font: 'italic 14px interstate-condensed, sans-serif' });
      draw.style('.clear', {fill: 'black', font: '14px interstate-condensed, sans-serif' });
      draw.style('.outline', {stroke: 'white', 'stroke-width': '4px', 'stroke-linejoin': 'round' });
      draw.style('.detail', {fill: 'black', font: 'bold 15px interstate-condensed, sans-serif'});
      draw.style('.star', {fill: 'black'});

      // TODO css for background colour
      var d = draw.rect(draw.width()-2, draw.height()-2).move(1, 1).css("fill", item.backgroundColor);
      if (item.border) d.addClass("stroke");

      if (item.divider) draw.line(1, 35, draw.width()-2, 35).addClass("stroke");

      if (item.image.length) {
        let i = draw.image(item.imageSource, function (event) {
          const maxWidth = draw.width() - padding * 4;
          const maxHeight = draw.height() - 35 - padding * 4;
          i.size(maxWidth, maxHeight).center(draw.width()/2, ((draw.height()-35)/2)+35);
          const id = draw.defs().multiply(item.backgroundColor);
          i.attr('filter', 'url(#' + id + ')');
        });
      }

      if (item.star) draw.star(5, 11, 5).center(17, 35/2).addClass("star");

      if (item.name.length) {
        draw.plain(item.name).move(item.star ? 32 : padding, 11).addClass("header");
      }

      for (let i = 0; i < item.usage; i++) {
        const x = padding + (i % 3) * 18;
        const y = 45 + Math.floor(i / 3) * 18;
        draw.circle(15).move(x, y).addClass("stroke").addOutline();
      }

      if (item.damage.length) {
        let group = draw.group();
        let label = group.plain(item.damage).addClass("damage");
        let bbox = label.bbox().grow(5);
        let box = group.rect(bbox.width, bbox.height).move(bbox.x, bbox.y).addClass("stroke").insertBefore(label).addOutline();
        group.move(draw.width() - padding - bbox.width, 35 + padding);
      }

      if (item.classDetail.length) {
        let label = draw.plain(item.classDetail).move(padding, draw.height() - padding - 17).addClass("detail").addOutline();
      }

      if (item.mechanicDetail.length) {
        var text = draw.text(function(t) {
          t.addClass("mechanics");
          t.leading('1.2em');
          t.wrap(item.mechanicDetail, 150 - padding * 2);
        }).move(8, item.divider ? 32 + padding : 32);
      }

      if (item.clearDetail.length) {
        var text = draw.text(function(t) {
          t.addClass("clear");
          t.leading('1.2em');
          t.tspan('Clear:').font('weight', 'bold').newLine();
          t.wrap(item.clearDetail, 150 - padding * 2);
        });
        text.move(padding, 150 - padding - text.bbox().height);
      }
    }
    </script>
    <script>
      const weapon = {
            name: 'Sword',
            usage: 3,
            damage: 'd6/d8',
            mechanicDetail: '',
            clearDetail: '',
            classDetail: 'Medium',
            image: 'Sword',
            imageSource: 'item-light-1.png',
            backgroundColor: '#ffffff',
            foregroundColor: '#000000',
            width: 1,
            height: 1,
            divider: true,
            border: true,
            star: false,
        };
      const armour = {
            name: 'Heavy armour',
            usage: 3,
            damage: '1 def',
            mechanicDetail: '',
            clearDetail: '',
            classDetail: 'Heavy',
            image: 'Heavy armour',
            imageSource: 'item-heavy-armour.png',
            backgroundColor: '#dfcb95',
            foregroundColor: '#000000',
            width: 1,
            height: 2,
            divider: true,
            border: true,
            star: false,
        };
      const spell = {
            name: 'Restore',
            usage: 3,
            damage: '',
            mechanicDetail: '',
            clearDetail: '',
            classDetail: '',
            image: 'Spell 1',
            imageSource: 'spell-1.png',
            backgroundColor: '#ffffff',
            foregroundColor: '#000000',
            width: 1,
            height: 1,
            divider: true,
            border: true,
            star: true,
        };
      const condition = {
            name: 'Injured',
            usage: 0,
            damage: '',
            mechanicDetail: 'Disadvantage on STR and DEX saves',
            clearDetail: 'After full rest',
            classDetail: '',
            image: '',
            backgroundColor: '#ff4444',
            foregroundColor: '#000000',
            width: 1,
            height: 1,
            divider: false,
            border: true,
            star: false,
        };
        const condition2 = {
            name: 'Injured',
            usage: 0,
            damage: '',
            mechanicDetail: 'Disadvantage on STR and DEX saves',
            clearDetail: 'After full rest',
            classDetail: '',
            image: '',
            backgroundColor: '#ff4444',
            foregroundColor: '#000000',
            width: 1,
            height: 1,
            divider: true,
            border: true,
            star: false,
        };
    renderItem(weapon);
    renderItem(armour);
    renderItem(spell);
    renderItem(condition);
    renderItem(condition2);
    </script>
  </body>
</html>
